// @ts-nocheck — Deno runtime file: deno.land imports and Deno.test are not recognized by VS Code TS server
/**
 * File: database_constraints.test.ts
 * Purpose: Property-based tests cho database constraints
 * Layer: Infrastructure / Testing
 * 
 * Data Contract:
 * - Input: Random test data generated by fast-check
 * - Output: Test assertions (pass/fail)
 * 
 * Flow:
 * 1. Generate random test data
 * 2. Attempt database operations
 * 3. Verify constraints are enforced
 * 
 * Security Note: Tests run on test database only
 * 
 * Feature: supabase-gemini-integration
 * Property 15: Gem Balance Non-Negativity Invariant
 * Validates: Requirements 4.3
 */

/// <reference path="./deno.d.ts" />
/// <reference path="./types.d.ts" />

// @deno-types="https://deno.land/std@0.208.0/assert/mod.ts"
import { assertEquals } from "https://deno.land/std@0.208.0/assert/mod.ts";
// @deno-types="https://esm.sh/@supabase/supabase-js@2.39.0"
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.0";
// @deno-types="https://cdn.skypack.dev/fast-check@3.15.0"
import * as fc from "https://cdn.skypack.dev/fast-check@3.15.0";

// Test configuration
const SUPABASE_URL = Deno.env.get("SUPABASE_TEST_URL") || "";
const SUPABASE_SERVICE_KEY = Deno.env.get("SUPABASE_TEST_SERVICE_KEY") || "";

if (!SUPABASE_URL || !SUPABASE_SERVICE_KEY) {
  console.error("⚠️  SUPABASE_TEST_URL và SUPABASE_TEST_SERVICE_KEY phải được set");
  console.error("   Để chạy tests, export các biến môi trường này:");
  console.error("   export SUPABASE_TEST_URL='https://your-project.supabase.co'");
  console.error("   export SUPABASE_TEST_SERVICE_KEY='your-service-key'");
  // Deno.exit(1); // Commented out for TypeScript compatibility
}

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY);

// Helper: Tạo test user
async function createTestUser(userId: string) {
  const { error } = await supabase
    .from("profiles")
    .insert({
      id: userId,
      gems_balance: 100,
      created_at: new Date().toISOString(),
    });

  if (error && !error.message.includes("duplicate")) {
    throw error;
  }
}

// Helper: Cleanup test user
async function cleanupTestUser(userId: string) {
  await supabase.from("profiles").delete().eq("id", userId);
}

/**
 * Property 15: Gem Balance Non-Negativity Invariant
 * 
 * Specification:
 * ∀ user_id, ∀ operation: gems_balance >= 0
 * 
 * Test Strategy:
 * - Generate random negative gem values
 * - Attempt to set gems_balance to negative
 * - Verify operation fails with CHECK constraint violation
 */
Deno.test({
  name: "Property 15: Gem Balance Non-Negativity Invariant",
  fn: async () => {
    const testUserId = `test-user-${crypto.randomUUID()}`;

    try {
      await createTestUser(testUserId);

      // Property test: Attempt to set negative balance should always fail
      await fc.assert(
        fc.asyncProperty(
          fc.integer({ min: -1000, max: -1 }), // Generate negative integers
          async (negativeBalance: number) => {
            // Attempt to update gems_balance to negative value
            const { error } = await supabase
              .from("profiles")
              .update({ gems_balance: negativeBalance })
              .eq("id", testUserId);

            // Verify: Operation must fail
            if (!error) {
              throw new Error(
                `VIOLATION: gems_balance set to ${negativeBalance} (expected: constraint error)`
              );
            }

            // Verify: Error is CHECK constraint violation
            const isCheckConstraintError =
              error.message.includes("check_gems_balance_non_negative") ||
              error.message.includes("violates check constraint") ||
              error.message.includes("gems_balance");

            if (!isCheckConstraintError) {
              throw new Error(
                `Wrong error type: ${error.message} (expected: CHECK constraint)`
              );
            }

            // Verify: Balance remains unchanged
            const { data } = await supabase
              .from("profiles")
              .select("gems_balance")
              .eq("id", testUserId)
              .single();

            if (data && data.gems_balance < 0) {
              throw new Error(
                `CRITICAL: gems_balance is ${data.gems_balance} (invariant violated!)`
              );
            }
          }
        ),
        { numRuns: 100 } // Run 100 iterations
      );

      console.log("✅ Property 15 verified: Gem balance non-negativity enforced");

    } finally {
      await cleanupTestUser(testUserId);
    }
  },
  sanitizeResources: false,
  sanitizeOps: false,
});

/**
 * Property 15b: Gem Balance Boundary Test
 * 
 * Test Strategy:
 * - Verify balance = 0 is allowed (boundary case)
 * - Verify balance = -1 is rejected (just below boundary)
 */
Deno.test({
  name: "Property 15b: Gem Balance Boundary (0 allowed, -1 rejected)",
  fn: async () => {
    const testUserId = `test-user-${crypto.randomUUID()}`;

    try {
      await createTestUser(testUserId);

      // Test 1: Balance = 0 should be allowed
      const { error: error0 } = await supabase
        .from("profiles")
        .update({ gems_balance: 0 })
        .eq("id", testUserId);

      assertEquals(error0, null, "Balance = 0 should be allowed");

      // Verify balance is 0
      const { data: data0 } = await supabase
        .from("profiles")
        .select("gems_balance")
        .eq("id", testUserId)
        .single();

      assertEquals(data0?.gems_balance, 0, "Balance should be exactly 0");

      // Test 2: Balance = -1 should be rejected
      const { error: errorNeg } = await supabase
        .from("profiles")
        .update({ gems_balance: -1 })
        .eq("id", testUserId);

      if (!errorNeg) {
        throw new Error("Balance = -1 should be rejected");
      }

      // Verify balance remains 0 (unchanged)
      const { data: dataAfter } = await supabase
        .from("profiles")
        .select("gems_balance")
        .eq("id", testUserId)
        .single();

      assertEquals(dataAfter?.gems_balance, 0, "Balance should remain 0 after failed update");

      console.log("✅ Property 15b verified: Boundary case (0 allowed, -1 rejected)");

    } finally {
      await cleanupTestUser(testUserId);
    }
  },
  sanitizeResources: false,
  sanitizeOps: false,
});

/**
 * Property 15c: Category Constraint Test
 * 
 * Test Strategy:
 * - Verify only valid categories are accepted
 * - Verify invalid categories are rejected
 */
Deno.test({
  name: "Property 15c: Wardrobe Category Constraint",
  fn: async () => {
    const testUserId = `test-user-${crypto.randomUUID()}`;

    try {
      await createTestUser(testUserId);

      const validCategories = ["top", "bottom", "dress", "shoes", "accessories"];

      // Test valid categories
      for (const category of validCategories) {
        const { error } = await supabase
          .from("wardrobe_items")
          .insert({
            user_id: testUserId,
            name: `Test ${category}`,
            category: category,
            image_url: "https://example.com/test.jpg",
          });

        assertEquals(error, null, `Valid category '${category}' should be accepted`);
      }

      // Property test: Invalid categories should always be rejected
      await fc.assert(
        fc.asyncProperty(
          fc.string({ minLength: 1, maxLength: 20 })
            .filter((s: string) => !validCategories.includes(s)), // Generate invalid categories
          async (invalidCategory: string) => {
            const { error } = await supabase
              .from("wardrobe_items")
              .insert({
                user_id: testUserId,
                name: "Test Item",
                category: invalidCategory,
                image_url: "https://example.com/test.jpg",
              });

            // Verify: Operation must fail
            if (!error) {
              throw new Error(
                `VIOLATION: Invalid category '${invalidCategory}' was accepted`
              );
            }

            // Verify: Error is CHECK constraint violation
            const isCheckConstraintError =
              error.message.includes("check_category_valid") ||
              error.message.includes("violates check constraint") ||
              error.message.includes("category");

            if (!isCheckConstraintError) {
              throw new Error(
                `Wrong error type: ${error.message} (expected: CHECK constraint)`
              );
            }
          }
        ),
        { numRuns: 50 }
      );

      console.log("✅ Property 15c verified: Category constraint enforced");

    } finally {
      // Cleanup
      await supabase.from("wardrobe_items").delete().eq("user_id", testUserId);
      await cleanupTestUser(testUserId);
    }
  },
  sanitizeResources: false,
  sanitizeOps: false,
});
